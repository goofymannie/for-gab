<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Happy Valentine's Day in 3D!</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #dc818c;
            --accent: #ecb1bf;
            --bg-light: #f0e0e0;
            --font: 'Montserrat', sans-serif;
            --transition: 0.3s ease;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: var(--font);
            background: #fdfdfd;
            overflow-x: hidden;
        }
        header {
            position: fixed;
            top: 0; left: 0; width: 100%;
            background: rgba(255,255,255,0.85);
            backdrop-filter: blur(5px);
            padding: 20px 40px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
        }
        header a {
            text-decoration: none;
            color: #333;
            font-weight: 600;
            transition: color var(--transition);
        }
        header a:hover { color: var(--primary); }
        /* Container for Three.js canvas */
        #threeContainer {
            width: 100%;
            height: 100vh;
            display: block;
        }
        /* Modal Overlay for media */
        .modal {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.75);
            justify-content: center;
            align-items: center;
            z-index: 200;
            padding: 20px;
        }
        .modal-content {
            background: var(--bg-light);
            padding: 30px;
            border-radius: 8px;
            max-width: 800px;
            width: 100%;
            text-align: center;
            position: relative;
            animation: fadeIn 0.5s ease forwards;
        }
        .close-modal {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 1.5rem;
            color: #666;
            cursor: pointer;
            transition: color var(--transition);
        }
        .close-modal:hover { color: var(--primary); }
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
        .media-placeholder {
            width: 100%;
            height: 400px;
            background-color: #ddd;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            margin: 15px 0;
            border-radius: 8px;
        }
        .modal img {
            max-width: 100%;
            max-height: 500px;
            border-radius: 8px;
            margin: 15px auto;
            display: block;
        }
        .modal video {
            max-width: 100%;
            border-radius: 8px;
            margin: 15px auto;
        }
        .modal h3 {
            color: var(--primary);
            margin-bottom: 15px;
        }
        .modal p {
            margin-bottom: 20px;
            line-height: 1.5;
        }
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
        #loadingText {
            margin-top: 20px;
            font-size: 1.5rem;
            color: var(--primary);
        }
        .loader {
            width: 48px;
            height: 48px;
            border: 5px solid var(--accent);
            border-bottom-color: var(--primary);
            border-radius: 50%;
            display: inline-block;
            box-sizing: border-box;
            animation: rotation 1s linear infinite;
        }
        @keyframes rotation {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>

    <!-- Loading screen -->
    <div id="loadingScreen">
        <span class="loader"></span>
        <div id="loadingText">Loading your special memories...</div>
    </div>

    <div id="threeContainer"></div>

    <div class="modal" id="mediaModal">
        <div class="modal-content" id="mediaModalContent">
            <span class="close-modal" id="closeMediaModal">&times;</span>
            <h3>Loading...</h3>
            <div class="media-placeholder">Loading media...</div>
        </div>
    </div>

    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
    <script>
        // Constants for media directories
        const VIDEOS_DIR = "videos/";
        const PHOTOS_DIR = "photos/";
        const AUDIO_DIR = "audios/"; // Directory for audio files

        // Single audio file
        const audioFile = {
            path: AUDIO_DIR + "clap.wav",
            title: "Clap"
        };

        // Audio elements and state
        let bgAudio = null;
        let isMuted = false;
        let volumeLevel = 0.7; // 70% initial volume

        // Initialize audio system
        function initAudioSystem() {
            console.log("Initializing audio system...");

            // Create audio element
            bgAudio = new Audio();

            // Set initial properties
            bgAudio.volume = volumeLevel;
            bgAudio.loop = false; // We'll handle advancing to next track ourselves

            // Load the audio file
            loadAudioFile();

            // Set up control buttons
            const muteButton = document.getElementById('muteButton');
            const volumeSlider = document.getElementById('volumeSlider');
            const playButton = document.getElementById('playButton');

            // Mute/unmute toggle
            muteButton.addEventListener('click', function() {
                toggleMute();
                updateMuteButtonIcon();
            });

            // Volume control
            volumeSlider.addEventListener('input', function() {
                volumeLevel = this.value / 100;
                if (!isMuted) {
                    bgAudio.volume = volumeLevel;
                }
                // If volume is set to 0, update mute button to show muted state
                updateMuteButtonIcon();
            });

            // Play button
            playButton.addEventListener('click', function() {
                bgAudio.play();
            });

            // Initial UI update
            updateNowPlaying();
            updateMuteButtonIcon();
        }

        // Load the audio file
        function loadAudioFile() {
            try {
                bgAudio.src = audioFile.path;
                bgAudio.load();

                // Only autoplay after user has interacted with the page
                // This is to comply with browser autoplay policies
                const playPromise = bgAudio.play();

                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        console.log('Autoplay prevented. Waiting for user interaction.');

                        // Add a play button if autoplay is prevented
                        if (!document.getElementById('initialPlayButton')) {
                            const playButton = document.createElement('button');
                            playButton.id = 'initialPlayButton';
                            playButton.innerHTML = 'Start Music';
                            playButton.style.position = 'fixed';
                            playButton.style.top = '50%';
                            playButton.style.left = '50%';
                            playButton.style.transform = 'translate(-50%, -50%)';
                            playButton.style.padding = '15px 30px';
                            playButton.style.backgroundColor = 'var(--primary)';
                            playButton.style.color = 'white';
                            playButton.style.border = 'none';
                            playButton.style.borderRadius = '30px';
                            playButton.style.fontSize = '1.2rem';
                            playButton.style.cursor = 'pointer';
                            playButton.style.zIndex = '10000';
                            playButton.style.boxShadow = '0 4px 10px rgba(0, 0, 0, 0.2)';

                            playButton.addEventListener('click', function() {
                                bgAudio.play();
                                this.remove();
                            });

                            document.body.appendChild(playButton);
                        }
                    });
                }

                // Update display
                updateNowPlaying();
            } catch (e) {
                console.error('Error loading audio file:', e);
            }
        }

        // Toggle mute/unmute
        function toggleMute() {
            isMuted = !isMuted;
            bgAudio.muted = isMuted;
        }

        // Update the mute button icon based on state
        function updateMuteButtonIcon() {
            const muteButton = document.getElementById('muteButton');

            // Determine if actually muted (either by mute button or volume at 0)
            const effectivelyMuted = isMuted || volumeLevel === 0;

            if (effectivelyMuted) {
                muteButton.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M3,9H7L12,4V20L7,15H3V9M16.59,12L14,9.41L15.41,8L18,10.59L20.59,8L22,9.41L19.41,12L22,14.59L20.59,16L18,13.41L15.41,16L14,14.59L16.59,12Z" />
                    </svg>
                `;
                muteButton.title = "Unmute";
            } else {
                muteButton.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M14,3.23V5.29C16.89,6.15 19,8.83 19,12C19,15.17 16.89,17.84 14,18.7V20.77C18,19.86 21,16.28 21,12C21,7.72 18,4.14 14,3.23M16.5,12C16.5,10.23 15.5,8.71 14,7.97V16C15.5,15.29 16.5,13.76 16.5,12M3,9V15H7L12,20V4L7,9H3Z" />
                    </svg>
                `;
                muteButton.title = "Mute";
            }
        }

        // Update now playing text
        function updateNowPlaying() {
            const nowPlayingElement = document.getElementById('nowPlaying');
            nowPlayingElement.textContent = `Now Playing: ${audioFile.title}`;
            nowPlayingElement.title = audioFile.title; // Add title for hover state to see full name
        }

        // Function to collect all media files based on the specified naming convention
        async function collectMediaFiles() {
            console.log("Collecting media files...");

            const mediaCollection = {
                videos: [],
                photos: []
            };

            // Using the naming convention provided: photo_1.jpg to photo_49.jpg and video_1.mp4 to video_5.mp4

            // Add photos
            for (let i = 1; i <= 49; i++) {
                const filename = `photo_${i}.jpg`;
                mediaCollection.photos.push({
                    path: PHOTOS_DIR + filename,
                    title: `Memory #${i}`,
                    description: `A beautiful moment captured in our journey together.`
                });
            }

            // Add videos
            for (let i = 1; i <= 5; i++) {
                const filename = `video_${i}.mp4`;
                mediaCollection.videos.push({
                    path: VIDEOS_DIR + filename,
                    title: `Special Video #${i}`,
                    description: `A cherished memory we can revisit again and again.`
                });
            }

            console.log("Media files collected:",
                mediaCollection.videos.length, "videos,",
                mediaCollection.photos.length, "photos");

            return mediaCollection;
        }

        // Main initialization function
        async function initValentineScene() {
            console.log("Initializing Valentine's Day scene...");

            // First collect all media files
            const mediaCollection = await collectMediaFiles();

            // Create a bearMediaData array by combining videos and photos
            const bearMediaData = [];

            // Add videos first
            mediaCollection.videos.forEach((video, index) => {
                bearMediaData.push({
                    type: "video",
                    path: video.path,
                    title: video.title || `Video Memory ${index + 1}`,
                    description: video.description || "A special moment captured on video."
                });
            });

            // Then add photos
            mediaCollection.photos.forEach((photo, index) => {
                bearMediaData.push({
                    type: "image",
                    path: photo.path,
                    title: photo.title || `Photo Memory ${index + 1}`,
                    description: photo.description || "A beautiful moment we shared together."
                });
            });

            // If we have fewer than 70 items, repeat some to reach 70
            if (bearMediaData.length < 70) {
                const originalLength = bearMediaData.length;
                for (let i = 0; i < 70 - originalLength; i++) {
                    const baseItem = bearMediaData[i % originalLength];
                    bearMediaData.push({
                        type: baseItem.type,
                        path: baseItem.path,
                        title: `${baseItem.title} ${Math.floor(i/originalLength) + 2}`,
                        description: baseItem.description
                    });
                }
            }

            // If we have more than 70 items, just use the first 70
            const fullBearMediaData = bearMediaData.slice(0, 70);

            // Now initialize the 3D scene with the collected media
            initScene(fullBearMediaData);
        }

        // Function to initialize the 3D scene
        function initScene(bearMediaData) {
            console.log("Setting up 3D scene with bears and media...");

            let scene, camera, renderer, controls, raycaster, mouse;
            const bearObjects = []; // Teddy bears with media
            const valentineObjects = []; // Valentine's Day themed objects
            const environmentObjects = []; // Environmental objects like trees
            let textMesh; // Reference to the text mesh
            const heartObjects = []; // Floating hearts

            // --- Valentine's Day Color Palette ---
            const valentineSkyColor = "#FCE6F2"; // Soft pink sky
            const valentineGroundColor = "#F9D9E2"; // Light pink ground
            const valentineTextColor = "#E55451"; // Deep pink text
            const valentineRoseColor = "#FF4040"; // Brighter red rose
            const valentinePetalColor = "#FFB6C1"; // Light pink petals
            const valentineHeartColor = "#FF69B4"; // Hot Pink hearts
            const valentineTeddyColor = "#69bdfc"; // Baby pink teddy bears
            const valentineTreeLeavesColor = "#FFC0CB"; // Pink tree leaves

            // Set up scene and camera
            scene = new THREE.Scene();
            scene.background = new THREE.Color(valentineSkyColor); // Soft pink sky background
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 12);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('threeContainer').appendChild(renderer.domElement);

            // OrbitControls for interactive rotation
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2; // Prevent viewing below the horizon

            // Raycaster for detecting clicks
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Lighting - Soft Warm Pink Light
            const ambientLight = new THREE.AmbientLight(0xFFB6C1, 0.7); // Soft pink ambient
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xFFDAB9, 0.5); // Peach directional
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            // --- Terrain ---
            const terrainGeometry = new THREE.PlaneGeometry(1000, 1000);
            const terrainMaterial = new THREE.MeshStandardMaterial({ color: valentineGroundColor }); // Light pink grass
            const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
            terrain.rotation.x = -Math.PI / 2;
            terrain.position.y = -1;
            scene.add(terrain);

            // --- Sky ---
            const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
            const skyMaterial = new THREE.MeshBasicMaterial({ color: valentineSkyColor, side: THREE.BackSide }); // Soft pink sky
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);

            // --- Clouds - Keep white clouds for contrast ---
            function createCloud() {
                const cloud = new THREE.Group(); // Use a group to combine spheres
                const cloudMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.6 });

                // Create multiple spheres with slight variations in size and position
                for (let i = 0; i < 3; i++) { // Create 3 spheres per cloud for more volume
                    const cloudGeometry = new THREE.SphereGeometry(Math.random() * 0.4 + 0.8, 16, 16); // Vary size
                    const mesh = new THREE.Mesh(cloudGeometry, cloudMaterial);
                    mesh.position.set(
                        (Math.random() - 0.5) * 0.5,
                        (Math.random() - 0.5) * 0.5,
                        (Math.random() - 0.5) * 0.5
                    ); // Offset spheres slightly
                    mesh.scale.set(1, Math.random() * 0.4 + 0.8, 1); // Non-uniform scale for less perfect shape
                    cloud.add(mesh);
                }

                cloud.position.set(
                    (Math.random() - 0.5) * 200,
                    Math.random() * 50 + 20,
                    (Math.random() - 0.5) * 200
                );
                return cloud;
            }

            for (let i = 0; i < 20; i++) {
                const cloud = createCloud();
                scene.add(cloud);
            }

            // --- Teddy Bear Creation - Pink Teddy Bears with Hearts and Media Indicators ---
            function createTeddyBear(mediaData) {
                const bear = new THREE.Group();
                bear.userData = mediaData; // Store media data for click events
                bear.userData.isClickable = true; // Mark as clickable
                bear.userData.phase = Math.random() * Math.PI * 2; // For animation

                const bearColor = valentineTeddyColor; // Baby pink for all bears

                // Body
                const bodyGeo = new THREE.SphereGeometry(1, 32, 32);
                const bodyMat = new THREE.MeshStandardMaterial({ color: bearColor });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.scale.set(1, 1.2, 1);
                bear.add(body);

                // Head
                const headGeo = new THREE.SphereGeometry(0.6, 32, 32);
                const head = new THREE.Mesh(headGeo, bodyMat);
                head.position.y = 1.4;
                bear.add(head);

                // Ears
                const earGeo = new THREE.SphereGeometry(0.2, 16, 16);
                const leftEar = new THREE.Mesh(earGeo, bodyMat);
                const rightEar = new THREE.Mesh(earGeo, bodyMat);
                leftEar.position.set(-0.4, 1.8, 0);
                rightEar.position.set(0.4, 1.8, 0);
                bear.add(leftEar);
                bear.add(rightEar);

                // Eyes - Keep black eyes for contrast
                const eyeGeo = new THREE.SphereGeometry(0.05, 8, 8);
                const eyeMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
                const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
                const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
                leftEye.position.set(-0.15, 1.45, 0.55);
                rightEye.position.set(0.15, 1.45, 0.55);
                bear.add(leftEye);
                bear.add(rightEye);

                // Nose - Keep black nose for contrast
                const noseGeo = new THREE.SphereGeometry(0.07, 8, 8);
                const nose = new THREE.Mesh(noseGeo, eyeMat);
                nose.position.set(0, 1.35, 0.65);
                bear.add(nose);

                // Arms
                const armGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.6, 16);
                const leftArm = new THREE.Mesh(armGeo, bodyMat);
                const rightArm = new THREE.Mesh(armGeo, bodyMat);
                leftArm.rotation.z = Math.PI / 4;
                rightArm.rotation.z = -Math.PI / 4;
                leftArm.position.set(-0.9, 0.8, 0);
                rightArm.position.set(0.9, 0.8, 0);
                bear.add(leftArm);
                bear.add(rightArm);

                // Legs
                const legGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.8, 16);
                const leftLeg = new THREE.Mesh(legGeo, bodyMat);
                const rightLeg = new THREE.Mesh(legGeo, bodyMat);
                leftLeg.position.set(-0.4, -0.9, 0);
                rightLeg.position.set(0.4, -0.9, 0);
                bear.add(leftLeg);
                bear.add(rightLeg);

                // Heart for Teddy Bear
                const heartShape = new THREE.Shape();
                heartShape.moveTo(0, 0);
                heartShape.bezierCurveTo(-0.25, -0.25, -0.25, 0, 0, 0.25);
                heartShape.bezierCurveTo(0.25, 0, 0.25, -0.25, 0, 0);

                const heartGeometry = new THREE.ShapeGeometry(heartShape);
                const heartMaterial = new THREE.MeshStandardMaterial({ color: valentineHeartColor });
                const heart = new THREE.Mesh(heartGeometry, heartMaterial);
                heart.scale.set(0.3, 0.3, 0.3);
                heart.position.set(0, 1, 0.7); // Position heart on chest
                heart.rotation.x = -Math.PI/4;
                bear.add(heart);

                // Media indicator based on type
                let indicatorColor = mediaData.type === "video" ? 0xFF0000 : 0x0088FF; // Red for video, blue for image
                const indicatorGeo = new THREE.SphereGeometry(0.15, 16, 16);
                const indicatorMat = new THREE.MeshStandardMaterial({
                    color: indicatorColor,
                    emissive: indicatorColor,
                    emissiveIntensity: 0.3
                });
                const indicator = new THREE.Mesh(indicatorGeo, indicatorMat);
                indicator.position.set(0, 2.2, 0); // Position above bear's head
                indicator.userData.isIndicator = true; // Mark as indicator to prevent hover effect
                bear.add(indicator);

                return bear;
            }

            // Place 70 teddy bears in the scene with media data using a heart formation
            function createHeartFormation(count, mediaData) {
                const bears = [];
                const scale = 4; // Scale factor for the heart size

                // Parametric equation for a heart shape
                function heartX(t) {
                    return scale * (16 * Math.pow(Math.sin(t), 3));
                }

                function heartY(t) {
                    return scale * (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
                }

                // Create bears and position them along the heart curve
                for (let i = 0; i < count; i++) {
                    const bear = createTeddyBear(mediaData[i]);

                    // Distribute bears evenly along the heart curve
                    const t = (i / count) * 2 * Math.PI;
                    const x = heartX(t);
                    const z = heartY(t);

                    bear.position.set(x, 0, z);
                    bear.rotation.y = Math.random() * Math.PI * 2; // Random rotation
                    bear.scale.set(0.8, 0.8, 0.8); // Slightly smaller for more bears in view

                    scene.add(bear);
                    bears.push(bear);
                }

                return bears;
            }

            // Create bears in a heart formation
            const bears = createHeartFormation(70, bearMediaData);
            bearObjects.push(...bears);

            // --- Valentine's Day Themed Objects ---
            function createRose() {
                const roseGroup = new THREE.Group();
                const petalMaterial = new THREE.MeshStandardMaterial({ color: valentineRoseColor, roughness: 0.7, metalness: 0 }); // Valentine red rose

                // Base Petal Shape (TorusGeometry for simple petal shape)
                const petalGeometry = new THREE.TorusGeometry(0.3, 0.1, 16, 32, Math.PI / 2); // Adjust parameters for petal shape
                for (let i = 0; i < 8; i++) { // Create multiple petals
                    const petal = new THREE.Mesh(petalGeometry, petalMaterial);
                    petal.rotation.x = Math.PI / 2; // Orient petals upright
                    petal.rotation.y = (i / 8) * Math.PI * 2; // Arrange in a circle
                    petal.position.y = 0.1; // Lift petals slightly off center
                    roseGroup.add(petal);
                }

                // Center Sphere (inner rose bud) - Pinker center
                const centerGeometry = new THREE.SphereGeometry(0.2, 32, 32);
                const centerMaterial = new THREE.MeshStandardMaterial({ color: valentinePetalColor, roughness: 0.7, metalness: 0 }); // Lighter pink center
                const center = new THREE.Mesh(centerGeometry, centerMaterial);
                roseGroup.add(center);

                const stemGeo = new THREE.CylinderGeometry(0.05, 0.05, 1, 16);
                const stemMat = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
                const stem = new THREE.Mesh(stemGeo, stemMat);
                stem.position.y = -0.65; // Position the stem below the rose
                roseGroup.add(stem);

                return roseGroup;
            }

            // Place roses around the heart perimeter
            for (let i = 0; i < 40; i++) {
                const rose = createRose();
                const t = (i / 40) * 2 * Math.PI;
                const scale = 5.5; // Slightly larger than the heart
                const x = scale * (16 * Math.pow(Math.sin(t), 3));
                const z = scale * (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));

                rose.position.set(
                    x,
                    Math.random() * 0.5, // Slight height variation
                    z
                );
                scene.add(rose);
                valentineObjects.push(rose);
            }

            // --- Heart Object ---
            function createHeart() {
                const heartShape = new THREE.Shape();
                heartShape.moveTo(0, 0);
                heartShape.bezierCurveTo(-0.5, -0.5, -0.5, 0, 0, 0.5);
                heartShape.bezierCurveTo(0.5, 0, 0.5, -0.5, 0, 0);

                const geometry = new THREE.ShapeGeometry(heartShape);
                const material = new THREE.MeshStandardMaterial({
                    color: valentineHeartColor,
                    emissive: valentineHeartColor,
                    emissiveIntensity: 0.5
                }); // Hot pink, slightly emissive
                const heart = new THREE.Mesh(geometry, material);
                heart.scale.set(2, 2, 2); // Larger hearts
                return heart;
            }

            // Floating Hearts
            for (let i = 0; i < 15; i++) {
                const heart = createHeart();
                heart.position.set(
                    (Math.random() - 0.5) * 100,
                    Math.random() * 40 + 30, // Hearts float higher in the sky
                    (Math.random() - 0.5) * 100
                );
                heart.userData.phase = Math.random() * Math.PI * 2; // For animation
                scene.add(heart);
                heartObjects.push(heart);
            }

            // --- Environmental Objects (e.g., Trees) - Pink Trees ---
            function createTree() {
                const trunkGeo = new THREE.CylinderGeometry(0.1, 0.1, 1, 16);
                const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(trunkGeo, trunkMat);

                const leavesGeo = new THREE.SphereGeometry(0.5, 32, 32);
                const leavesMat = new THREE.MeshStandardMaterial({ color: valentineTreeLeavesColor }); // Pink leaves
                const leaves = new THREE.Mesh(leavesGeo, leavesMat);
                leaves.position.y = 0.75;

                const tree = new THREE.Group();
                tree.add(trunk);
                tree.add(leaves);
                return tree;
            }

            // Place pink trees around the environment
            for (let i = 0; i < 30; i++) {
                const tree = createTree();
                // Position trees in a circle around the edge of the scene
                const angle = (i / 30) * Math.PI * 2;
                const radius = 80; // Far enough to frame the scene

                tree.position.set(
                    Math.cos(angle) * radius,
                    0,
                    Math.sin(angle) * radius
                );
                scene.add(tree);
                environmentObjects.push(tree);
            }

            // --- 3D Text in the Sky - Valentine's Message and Color ---
            const loader = new THREE.FontLoader();
            loader.load('https://unpkg.com/three@0.128.0/examples/fonts/helvetiker_regular.typeface.json', function (font) {
                const textGeometry = new THREE.TextGeometry('You Are The Love I Never Knew I Needed', {
                    font: font,
                    size: 5,
                    height: 2,
                    curveSegments: 15,
                    bevelEnabled: true,
                    bevelThickness: 0.5,
                    bevelSize: 0.5,
                    bevelOffset: 0,
                    bevelSegments: 3
                });

                textGeometry.computeBoundingBox();
                const textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;

                const textMaterial = new THREE.MeshStandardMaterial({
                    color: valentineTextColor,
                    emissive: valentineTextColor,
                    emissiveIntensity: 0.3
                }); // Valentine pink text color with glow

                textMesh = new THREE.Mesh(textGeometry, textMaterial);
                textMesh.position.set(-textWidth/2, 20, 0); // Center the text horizontally
                textMesh.userData.phase = Math.random() * Math.PI * 2; // Add a phase for animation
                scene.add(textMesh);
            });

            // --- Initialize Mouse Move event for bear hover effects ---
            let hoveredBear = null;

            window.addEventListener('mousemove', (event) => {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);

                const intersects = raycaster.intersectObjects(scene.children, true);

                let foundBear = false;

                for (let i = 0; i < intersects.length; i++) {
                    // Find the parent bear of the intersected object
                    let parent = intersects[i].object;
                    while (parent && !parent.userData.isClickable) {
                        parent = parent.parent;
                    }

                    if (parent && parent.userData.isClickable) {
                        if (hoveredBear !== parent) {
                            // Remove hover effect from previous bear
                            if (hoveredBear) {
                                hoveredBear.userData.isHovered = false;
                                hoveredBear.traverse((child) => {
                                    if (child.isMesh && !child.userData.isIndicator) {
                                        child.material.emissive = new THREE.Color(0x000000);
                                    }
                                });
                            }

                            // Add hover effect to current bear
                            parent.userData.isHovered = true;
                            parent.traverse((child) => {
                                if (child.isMesh && !child.userData.isIndicator) {
                                    child.material.emissive = new THREE.Color(0x331111);
                                }
                            });

                            hoveredBear = parent;
                        }
                        foundBear = true;
                        break;
                    }
                }

                if (!foundBear && hoveredBear) {
                    // Remove hover effect if no bear is hovered
                    hoveredBear.userData.isHovered = false;
                    hoveredBear.traverse((child) => {
                        if (child.isMesh && !child.userData.isIndicator) {
                            child.material.emissive = new THREE.Color(0x000000);
                        }
                    });
                    hoveredBear = null;
                }
            });

            // --- Interactivity via Raycasting ---
            window.addEventListener('click', (event) => {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);

                const intersects = raycaster.intersectObjects(scene.children, true);

                for (let i = 0; i < intersects.length; i++) {
                    // Find the parent bear of the intersected object
                    let parent = intersects[i].object;
                    while (parent && !parent.userData.isClickable) {
                        parent = parent.parent;
                    }

                    if (parent && parent.userData.isClickable) {
                        openMediaModal(parent.userData);
                        break;
                    }
                }
            });

            // --- Initialize Clock for Animation ---
            const clock = new THREE.Clock();

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                const elapsedTime = clock.getElapsedTime();
                const deltaTime = clock.getDelta();

                // Animate teddy bears - gentle bobbing and hovering indication
                bearObjects.forEach(bear => {
                    if (!bear.userData.isHovered) {
                        // Normal bobbing animation for non-hovered bears
                        bear.position.y = 0.5 * Math.sin(elapsedTime + bear.userData.phase);
                    } else {
                        // Excited bobbing for hovered bears
                        bear.position.y = 0.6 * Math.sin(elapsedTime * 1.5 + bear.userData.phase);
                    }
                });

                // Animate text
                if (textMesh) {
                    textMesh.position.y = 20 + 2 * Math.sin(elapsedTime * 0.5 + textMesh.userData.phase);
                }

                // Animate Floating Hearts
                heartObjects.forEach(heart => {
                    heart.position.y = 30 + Math.sin(elapsedTime + heart.userData.phase) * 5 + 5; // Float up and down
                    heart.rotation.y = elapsedTime * 0.1; // Slowly rotate
                    heart.rotation.z = Math.sin(elapsedTime * 0.5) * 0.1; // Slight wobble
                });

                renderer.render(scene, camera);
            }
            animate();

            // --- Modal Functions ---
            const mediaModal = document.getElementById('mediaModal');
            const mediaModalContent = document.getElementById('mediaModalContent');
            document.getElementById('closeMediaModal').addEventListener('click', () => {
                closeMediaModal();
            });

            window.addEventListener('click', (e) => {
                if (e.target === mediaModal) {
                    closeMediaModal();
                }
            });

            // Function to close the media modal
            function closeMediaModal() {
                mediaModal.style.display = 'none';
                // Stop any videos when closing the modal
                const videoElements = mediaModalContent.querySelectorAll('video');
                videoElements.forEach(video => {
                    video.pause();
                    video.currentTime = 0;
                });
            }

            // Function to open media modal
            function openMediaModal(mediaData) {
                console.log("Opening modal with media data:", mediaData);

                // Create the modal content based on media type
                let mediaContent = "";

                if (mediaData.type === "video") {
                    // Check if video file exists (this is client-side so we can only do a basic check)
                    mediaContent = `
                        <video controls autoplay style="width:100%; max-height:500px; border-radius:8px;">
                            <source src="${mediaData.path}" type="video/mp4">
                            Your browser does not support video playback or the file may not exist.
                        </video>
                    `;
                } else if (mediaData.type === "image") {
                    // For images, we add an onerror handler to show a message if the image doesn't load
                    mediaContent = `
                        <img src="${mediaData.path}" alt="${mediaData.title}"
                             style="max-width:100%; max-height:500px; border-radius:8px;"
                             onerror="this.onerror=null; this.src=''; this.alt='Image could not be loaded';
                                      this.style.display='none';
                                      this.parentNode.innerHTML += '<div class=\\'media-placeholder\\'>Image not found: ${mediaData.path}</div>';">
                    `;
                } else {
                    mediaContent = `
                        <div class="media-placeholder">No media available</div>
                    `;
                }

                // Update the modal content
                mediaModalContent.innerHTML = `
                    <span class="close-modal" id="closeMediaModal">&times;</span>
                    <h3>${mediaData.title}</h3>
                    <p>${mediaData.description}</p>
                    ${mediaContent}
                `;

                // Display the modal
                mediaModal.style.display = 'flex';

                // Re-attach click event to close button
                document.getElementById('closeMediaModal').addEventListener('click', () => {
                    closeMediaModal();
                });
            }

            // Function to handle window resize
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            window.addEventListener('resize', onWindowResize);

            // Add info tooltip
            const instructions = document.createElement('div');
            instructions.style.position = 'fixed';
            instructions.style.bottom = '20px';
            instructions.style.left = '20px';
            instructions.style.padding = '10px 15px';
            instructions.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
            instructions.style.borderRadius = '8px';
            instructions.style.fontFamily = 'var(--font)';
            instructions.style.color = '#333';
            instructions.style.fontSize = '14px';
            instructions.style.zIndex = '100';
            instructions.innerHTML = 'Hover over bears to highlight them<br>Click on bears to view photos & videos';
            document.body.appendChild(instructions);

            // Add directory info for troubleshooting
            const directoryInfo = document.createElement('div');
            directoryInfo.style.position = 'fixed';
            directoryInfo.style.top = '80px';
            directoryInfo.style.right = '20px';
            directoryInfo.style.padding = '10px 15px';
            directoryInfo.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
            directoryInfo.style.borderRadius = '8px';
            directoryInfo.style.fontFamily = 'var(--font)';
            directoryInfo.style.color = '#333';
            directoryInfo.style.fontSize = '12px';
            directoryInfo.style.zIndex = '100';
            directoryInfo.style.maxWidth = '250px';

            document.body.appendChild(directoryInfo);

            // Show instructions for 8 seconds then fade out
            setTimeout(() => {
                instructions.style.transition = 'opacity 1s ease';
                instructions.style.opacity = '0';
                // Remove from DOM after fade out
                setTimeout(() => {
                    document.body.removeChild(instructions);
                }, 1000);
            }, 8000);

            // Hide loading screen once everything is ready
            document.getElementById('loadingScreen').style.display = 'none';
        }

        // Start the initialization process
        initValentineScene();
    </script>
</body>
</html>
